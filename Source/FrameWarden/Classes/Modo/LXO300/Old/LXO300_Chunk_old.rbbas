#tag ClassProtected Class LXO300_Chunk_old	#tag Method, Flags = &h0		Function GetChunkType() As String		  // This returns the main chunk type of an instance of this class		  		  Dim typeStr As String		  		  typeStr = Chr(Type.Byte(0)) + Chr(Type.Byte(1)) + Chr(Type.Byte(2)) + Chr(Type.Byte(3))		  		  Return typeStr		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetItemName() As String		  // If the data type of this chunk is an ITEM then this function returns the name of the item (IE. MyReallyCoolBox)		  		  Dim itemName As String		  		  if me.Type = "ITEM" then		    itemName = me.GetItemType()		    itemName = Read_String		    		    return itemName		  end if		  		  return ""		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetItemType() As String		  // If the data type of this chunk is an ITEM then this function returns the type of the item (IE. mesh or camera)		  Dim typeString As String		  		  dataMarker = 0		  		  if me.GetChunkType = "ITEM" then		    typeString = Read_String		    		    return typeString		  end if		  		  return ""		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetNextChunkType() As String		  // This returns the next sub chunk type based on the marker's current position		  		  Dim i As Int32		  		  i = dataMarker		  dataMarker = i + 4		  		  return Chr(Data.Byte(i)) + Chr(Data.Byte(i + 1)) + Chr(Data.Byte(i + 2)) + Chr(Data.Byte(i + 3))		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetRefID() As Int32		  Dim junkStr As String		  		  if me.Type = "ITEM" then		    junkStr = me.GetItemType + me.GetItemName		    		    return Read_Long		  end if		  		  return gNoFrameToRender		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetRenderExtension() As String		  Dim junkStr, renderExt As String		  Dim junkInt, length, i as Int32		  		  if me.GetChunkType = "ITEM" then		    me.dataMarker = 0		    		    junkStr = me.Read_String		    junkStr = me.Read_String		    		    junkInt = me.Read_Long		    		    While me.dataMarker < me.Size		      // Read in each chunk		      if me.GetNextChunkType = "CHNS" then		        length = me.Read_UShort		        		        junkStr = me.Read_String		        renderExt = me.Read_String		        		        if junkStr = "format" then		          		          Select Case renderExt		            		          Case "$FLEX"		            Return ".flx"		            		          Case "$Targa", "TGA"		            Return ".tga"		            		          Case "BMP"		            Return ".bmp"		            		          Case "GIF"		            Return ".gif"		            		          Case "HDR"		            Return ".hdr"		            		          Case "JPG"		            Return ".jpg"		            		          Case "PNG"		            Return ".png"		            		          Case "SGI"		            Return ".sgi"		            		          Case "TIF", "TIF16", "TIF16BIG"		            Return ".tif"		            		          Case "XPM"		            Return ".xpm"		            		          Case "openexr"		            Return ".exr"		            		          Case ""		            Return ""		            		          Else		            Return renderExt		          End Select		          		        else		          renderExt = ""		        end if		        		      else		        dataMarker = dataMarker + me.Read_UShort		      end if		    Wend		  end if		  		  return ""		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetRenderPath() As String		  Dim junkStr, renderPath As String		  Dim junkInt, length, i as Int32		  		  if me.GetChunkType = "ITEM" then		    me.dataMarker = 0		    		    junkStr = me.Read_String		    		    if junkStr = "renderOutput" then		      junkStr = me.Read_String		      junkInt = me.Read_Long		      		      While me.dataMarker < me.Size		        // Read in each chunk		        if me.GetNextChunkType = "CHNS" then		          length = me.Read_UShort		          		          junkStr = me.Read_String		          renderPath = me.Read_String		          		          if junkStr = "filename" then		            if renderPath <> "" then		              Return renderPath		            end if		          end if		          		        else		          dataMarker = dataMarker + me.Read_UShort		        end if		      Wend		    end if		  end if		  		  return ""		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetVMAPName() As String		  Dim tempStr As String		  		  tempStr = GetVMAPType		  		  tempStr = Str(Read_UShort)		  		  return Read_String		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetVMAPType() As String		  dataMarker = 0		  		  Return me.Read_ID4		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function IsMesh() As Boolean		  // If this chunk is an ITEM it will determine whether or not this chunk is a mesh		  		  if me.GetChunkType = "ITEM" then		    if Chr(Data.Byte(0)) + Chr(Data.Byte(1)) + Chr(Data.Byte(2)) + Chr(Data.Byte(3)) = "mesh" then		      return true		    end if		  end if		  		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Key_Count() As Int32		  // This function counts the number of keyframes in an ENVL chunk		  		  Dim i as Int32		  Dim keyCount As Int32		  		  if me.GetChunkType = "ENVL" then		    for i = 1 to me.Size - 3		      if Chr(Data.Byte(i)) = "K" then		        if Chr(Data.Byte(i+1)) = "E" then		          if Chr(Data.Byte(i+2)) = "Y" then		            if Chr(Data.Byte(i+3)) = " " then		              keyCount = keyCount + 1		              i = i + 3		            end if		          end if		        end if		      end if		    next		  end if		  		  return keyCount		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogACTN()		  Dim i, junk as Int32		  		  WriteToLog "Partially documented Data Type: ACTN", LogFuncs.LXO		  		  WriteToLog Read_String, LogFuncs.LXO		  WriteToLog Read_String, LogFuncs.LXO		  		  WriteToLog Str(Read_Long), LogFuncs.LXO		  		  while dataMarker < me.Size - 1		    //WriteToLog ""		    		    LogChunkData_Next(GetNextChunkType)		    		    if UserCancelled then		      exit		    end if		  wend		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogCHAN()		  Dim i, len, junk, chanType, otherDat, curveDat as Int32		  Dim tempFloat As Single		  		  len = Read_UShort		  		  WriteToLog "Partially documented Data Type: CHAN", LogFuncs.LXO		  		  WriteToLog "Size: " + Str(len), LogFuncs.LXO		  		  //chanType = Read_UShort		  //WriteToLog "CHAN TYPE: " + GetChannelType(chanType)		  		  //curveDat = Read_Byte		  //WriteToLog Str(junk) + " <- ? Curve, Linear, Stepped ?"		  //otherDat = Read_Byte		  //WriteToLog Str(junk) + " <- Bitwise AND 16 = has ENVL"		  		  //junk = Read_UShort		  //WriteToLog Str(junk) + " <- ENVL ID"		  		  if len = 10 then		    //if chanType = 165 or chanType = 166 then		    WriteToLog "Frame: " + Str(Read_UShort), LogFuncs.LXO		    		    junk = Read_Long		    		    //if junk = 2347 or junk = 2400 then		    if chanType = 165 or chanType = 166 or chanType = 225 or chanType = 226 then		      WriteToLog "CHAN TYPE: " + GetChannelType(chanType), LogFuncs.LXO		      WriteToLog "Curve Data: " + Str(curveDat), LogFuncs.LXO		      WriteToLog "Other Data: " + Str(otherDat), LogFuncs.LXO		      WriteToLog "Value: " + Str(junk), LogFuncs.LXO		      WriteToLog "", LogFuncs.LXO		    end if		    		    junk = Read_Long		    		    WriteToLog "Frame: " + Str(Junk), LogFuncs.LXO		    		  else		    for i = 1 to len		      junk = Read_Byte		      //WriteToLog Str(junk)		    next		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogCHNS()		  Dim i, len as Int32		  Dim CHNSstring As String		  		  WriteToLog "CHNS:", LogFuncs.LXO		  		  len = Read_UShort		  		  WriteToLog "Size: " + Str(len), LogFuncs.LXO		  		  for i = 1 to len		    CHNSstring = Str(Read_Byte)		    WriteToLog CHNSstring, LogFuncs.LXO		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogCHNV()		  Dim channelType As Int32		  Dim i, i2, dataLen, numElements As Int32		  		  WriteToLog "CHNV:", LogFuncs.LXO		  		  WriteToLog Str(Read_UShort), LogFuncs.LXO		  		  WriteToLog "Channel name: " + Read_String, LogFuncs.LXO		  		  channelType = Read_UShort		  		  numElements = Read_UShort		  WriteToLog "Element Count: " + Str(numElements), LogFuncs.LXO		  		  for i = 1 to numElements		    		    WriteToLog Read_String + ": ", LogFuncs.LXO		    		    select case channelType		    case 1		      WriteToLog "Int32: " + Str(Read_Long), LogFuncs.LXO		    case 2		      WriteToLog "Float: " + Str(Read_Float), LogFuncs.LXO		    case 3		      WriteToLog "String: " + Read_String, LogFuncs.LXO		    case 4		      dataLen = Read_UShort		      		      for i2 = 1 to dataLen		        WriteToLog Chr(Read_Byte), LogFuncs.LXO		      next		      		    end select		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub LogChunkData()		  dataMarker = 0		  		  select case GetChunkType		  case "ACTN"		    LogACTN		  case "ENVL"		    LogENVL		  case "ITEM"		    LogITEM		  case "LAYR"		    LogLAYR		  case "VMAD"		    LogVMAD		  case "VMAP"		    LogVMAP		  else		    LogGeneric		  end select		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub LogChunkData_Next(chunkType As String)		  Dim datLen, i, junkDat As Int32		  		  select case chunkType		  case "CHAN"		    LogCHAN		  case "CHNS"		    LogCHNS		  case "CHNV"		    LogCHNV		  case "ITEM"		    LogITEM_sub		  case "LAYR"		    LogLAYR_sub		  case "LINK"		    LogLINK		  case "UIDX"		    LogUIDX		  case "UNIQ"		    LogUNIQ		  else		    datLen = Read_UShort		    		    //WriteToLog "Data Length: " + Str(datLen)		    		    for i = 1 to datLen		      junkDat = Read_Byte		      //WriteToLog Str(junkDat)		      		      if i >= me.size then		        exit		      end if		    next		  end select		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogENVL()		  Dim nextChunk As String		  Dim time, value As Single		  		  WriteToLog "Number of keys: " + Str(Key_Count), LogFuncs.LXO		  		  // Read initial 6 bytes		  WriteToLog "Envelope ID: " + Str(Read_UShort), LogFuncs.LXO		  WriteToLog Str(Read_Byte), LogFuncs.LXO		  WriteToLog Str(Read_Byte), LogFuncs.LXO		  WriteToLog Str(Read_Byte), LogFuncs.LXO		  WriteToLog Str(Read_Byte), LogFuncs.LXO		  		  while dataMarker < me.Size		    nextChunk = GetNextChunkType		    		    WriteToLog Chr(13) + nextChunk, LogFuncs.LXO		    		    select case nextChunk		    Case "PRE ", "POST"		      WriteToLog Str(Read_UShort), LogFuncs.LXO		      WriteToLog Str(Read_UShort), LogFuncs.LXO		      		    Case "KEY "		      WriteToLog "Data Size: " + Str(Read_UShort), LogFuncs.LXO		      		      WriteToLog "-> Time: " + Str(Read_Float), LogFuncs.LXO		      WriteToLog "-> Value: " + Str(Read_Float), LogFuncs.LXO		      		    Case "IKEY"		      WriteToLog "Data Length: " + Str(Read_UShort), LogFuncs.LXO		      		      time = Read_Float		      value = Read_Float		      		      WriteToLog "-> Time: " + Str(time) + " or Frame: " + Str(time*24), LogFuncs.LXO		      WriteToLog "-> Value: " + Str(value), LogFuncs.LXO		      		    Case "TANI"		      //dataMarker = dataMarker + 18 // 2 for data size, 16 for actual data		      WriteToLog "Size: " + Str(Read_UShort) + Chr(13), LogFuncs.LXO		      WriteToLog "Slope Type: " + Str(Read_UShort), LogFuncs.LXO		      WriteToLog "Weight Type: " + Str(Read_UShort), LogFuncs.LXO		      WriteToLog "Weight: " + Str(Read_Float), LogFuncs.LXO		      WriteToLog "Slope: " + Str(Read_Float), LogFuncs.LXO		      WriteToLog "Value: " + Str(Read_Float), LogFuncs.LXO		      		    Case "TANO"		      WriteToLog "Size: " + Str(Read_UShort), LogFuncs.LXO		      		      WriteToLog "Breaks: " + Str(Read_Long), LogFuncs.LXO		      WriteToLog "Slope Type: " + Str(Read_UShort), LogFuncs.LXO		      WriteToLog "Weight Type: " + Str(Read_UShort), LogFuncs.LXO		      		      WriteToLog "Weight: " + Str(Read_Float), LogFuncs.LXO		      WriteToLog "Slope: " + Str(Read_Float), LogFuncs.LXO		      WriteToLog "Value: " + Str(Read_Float), LogFuncs.LXO		      		    Case "FLAG"		      WriteToLog "Size: " + Str(Read_UShort), LogFuncs.LXO		      WriteToLog "Flag1: " + Str(Read_Byte), LogFuncs.LXO		      WriteToLog "Flag2: " + Str(Read_Byte), LogFuncs.LXO		      WriteToLog "Flag3: " + Str(Read_Byte), LogFuncs.LXO		      WriteToLog "Flag4: " + Str(Read_Byte), LogFuncs.LXO		    else		      LogChunkData_Next(nextChunk)		      		    end select		  wend		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub LogGeneric()		  // This will log a generic log.  Basically, it will just display a long string of all of the bytes written out in Ascii		  		  Dim i as Int32		  Dim outString As String		  		  for i = 0 to me.Size - 1		    outString = outString + Chr(Data.Byte(i))		  next		  		  WriteToLog "GENERIC LOG:" + Chr(13), LogFuncs.LXO		  		  WriteToLog outString, LogFuncs.LXO		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogITEM()		  Dim nextChunk As String		  		  WriteToLog ("ITEM:" + chr(13), LogFuncs.LXO)		  		  WriteToLog "Type: " + Read_String, LogFuncs.LXO		  WriteToLog "Type: " + Read_String, LogFuncs.LXO		  WriteToLog "Ref ID: " + Str(Read_Long), LogFuncs.LXO		  		  while dataMarker < me.Size		    nextChunk = GetNextChunkType		    WriteToLog Chr(13) + "Next Chunk: " + nextChunk, LogFuncs.LXO		    LogChunkData_Next(nextChunk)		  wend		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogITEM_sub()		  WriteToLog "Partially documented Data Type: ITEM", LogFuncs.LXO		  WriteToLog "Data Length: " + Str(Read_UShort), LogFuncs.LXO		  		  WriteToLog Str(Read_Long) + " <- This is the ITEM number reference", LogFuncs.LXO		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogLAYR()		  WriteToLog "LWO2 index: " + Str(Read_UShort), LogFuncs.LXO		  WriteToLog "Flags: " + Str(Read_UShort), LogFuncs.LXO		  WriteToLog "Pivot - X: " + Str(Read_Float) + "   Y:" + Str(Read_Float) + "   Z:" + Str(Read_Float), LogFuncs.LXO		  		  WriteToLog "Layer name: " + Read_String, LogFuncs.LXO		  		  WriteToLog "LWO2 parent index: " + Str(Read_UShort), LogFuncs.LXO		  		  WriteToLog "Sub-D Freeze refinement level: " + Str(Read_Float), LogFuncs.LXO		  		  WriteToLog "Curve Freeze refinement level: " + Str(Read_Float), LogFuncs.LXO		  		  WriteToLog "Transformation -", LogFuncs.LXO		  WriteToLog " X:" + Str(Read_Float) + " Y:" + Str(Read_Float) + " Z:" + Str(Read_Float), LogFuncs.LXO		  WriteToLog " H:" + Str(Read_Float) + " P:" + Str(Read_Float) + " B:" + Str(Read_Float), LogFuncs.LXO		  WriteToLog " SX:" + Str(Read_Float) + " SY:" + Str(Read_Float) + " SZ:" + Str(Read_Float), LogFuncs.LXO		  		  WriteToLog "Mesh layer item reference: " + Str(Read_Long), LogFuncs.LXO		  		  WriteToLog "Splinepatch Freeze refinement level: " + Str(Read_UShort), LogFuncs.LXO		  		  WriteToLog "Reserved refinement level: " + Str(Read_UShort), LogFuncs.LXO		  WriteToLog "Reserved refinement level: " + Str(Read_Long), LogFuncs.LXO		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogLAYR_sub()		  WriteToLog Str(Read_UShort), LogFuncs.LXO		  		  WriteToLog "Layer Index: " + Str(Read_Long), LogFuncs.LXO		  WriteToLog "Layer Flags: " + Str(Read_Long), LogFuncs.LXO		  WriteToLog "Element Color: ", LogFuncs.LXO		  WriteToLog " - R: " + Str(Read_Byte), LogFuncs.LXO		  WriteToLog " - G: " + Str(Read_Byte), LogFuncs.LXO		  WriteToLog " - B: " + Str(Read_Byte), LogFuncs.LXO		  WriteToLog " - A: " + Str(Read_Byte), LogFuncs.LXO		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogLINK()		  WriteToLog Str(Read_UShort), LogFuncs.LXO		  		  WriteToLog Read_String, LogFuncs.LXO		  		  WriteToLog "Linked to ITEM #" + Str(Read_Long), LogFuncs.LXO		  WriteToLog "Link index: " + Str(Read_Long), LogFuncs.LXO		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogPRNT()		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogUIDX()		  Dim i, datLen as UInt16		  		  datLen = Read_UShort		  		  WriteToLog "Partially documented Data Type: UIDX", LogFuncs.LXO		  WriteToLog "Size: " + Str(datLen), LogFuncs.LXO		  		  for i = 1 to datLen		    WriteToLog Str(Read_Byte), LogFuncs.LXO		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogUNIQ()		  WriteToLog Str(Read_UShort), LogFuncs.LXO		  WriteToLog "Unique item ID: " + Read_String, LogFuncs.LXO		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogVMAD()		  Dim dimensions as integer		  		  me.dataMarker = 0		  		  // VMAD Type		  WriteToLog Read_ID4, LogFuncs.LXO		  		  dimensions = Read_UShort		  		  // VMAD Name		  WriteToLog "Name:" + Read_String, LogFuncs.LXO		  		  dataMarker = 0		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LogVMAP()		  Dim dimensions as integer		  		  me.dataMarker = 0		  		  // VMAP Type		  WriteToLog Read_ID4, LogFuncs.LXO		  		  dimensions = Read_UShort		  		  // VMAP Name		  WriteToLog "Name:" + Read_String, LogFuncs.LXO		  		  dataMarker = 0		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ReadInChunk(Byref inFile As BinaryStream)		  Dim i as Int32		  		  me.Type = NewMemoryBlock(4)		  		  if TargetLittleEndian then		    me.Type.LittleEndian = False		  end if		  		  me.Type.Long(0) = inFile.ReadLong		  		  Size = inFile.ReadLong		  		  Data = NewMemoryBlock(Size)		  		  // Make sure the Data block is or isn't LittleEndian		  if TargetLittleEndian then		    me.Data.LittleEndian = False		  end if		  		  // Check to see if it's an ITEM chunk, if it isn't it needs to be skipped		  if me.Type = "ITEM" then		    for i = 1 to Size		      Data.Byte(i-1) = inFile.ReadByte		      		      if i = 1 then		        // if the first character isn't an "r" then it can't be a render output and needs to be skipped		        if Data.Byte(0) <> asc("r") then		          inFile.Position = inFile.Position + Size - 1		          exit		        end if		      end if		    next		  elseif me.Type = "VMAP" then		    for i = 1 to Size		      Data.Byte(i-1) = inFile.ReadByte		    next		  else		    inFile.Position = inFile.Position + me.Size		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Read_Byte() As Int8		  Dim i as Int8		  		  i = me.Data.Byte(dataMarker)		  		  dataMarker = dataMarker + 1		  		  return i		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read_Double() As Double		  Dim d As Double		  		  d = Data.DoubleValue(dataMarker)		  dataMarker = dataMarker + 8		  		  return d		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read_Float() As Double		  Dim d As Double		  		  d = Data.SingleValue(dataMarker)		  dataMarker = dataMarker + 4		  		  return d		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read_ID4() As String		  return chr(Read_Byte) + chr(Read_Byte) + chr(Read_Byte) + chr(Read_Byte)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read_Long() As Int32		  Dim i as Int32		  		  i = Data.Long(dataMarker)		  		  dataMarker = dataMarker + 4		  		  return i		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read_Single() As Single		  Dim s As Single		  		  s = Data.SingleValue(dataMarker)		  dataMarker = dataMarker + 4		  		  return s		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read_String() As String		  Dim returnString As String		  		  while me.Data.Byte(dataMarker) <> 0		    returnString = returnString + Chr(me.Data.Byte(dataMarker))		    dataMarker = dataMarker + 1		  wend		  		  UnpadStringMarkerZeros		  		  return returnString		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read_UShort() As UInt16		  Dim i as UInt16		  		  i = Data.UShort(dataMarker)		  		  dataMarker = dataMarker + 2		  		  return i		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub UnpadStringMarkerZeros()		  // Strings are padded based on whether or not they are on an even bit or not.		  // Increment the data marker 1 or 2 more time so we don't leave off on the ZERO terminator		  if (dataMarker mod 2) = 1 then		    dataMarker = dataMarker + 1		  else		    dataMarker = dataMarker + 2		  end if		End Sub	#tag EndMethod	#tag Property, Flags = &h0		Data As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h0		dataMarker As Int32	#tag EndProperty	#tag Property, Flags = &h0		Size As Int32	#tag EndProperty	#tag Property, Flags = &h0		Type As MemoryBlock	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass